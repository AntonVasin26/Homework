Вариативный шаблон - обрабатывает неизвестное число аргументов произвольных типов
вариативные выражения
вариативные шаблоны

1)Приведите примеры ситуация в которых удобно использовать вариативные шаблоны
	1)В тех ситуациях когды мы незнаем сколько переменных и какого вида переменные поступает на вход программы.
	(пускай будет анализ багажа при погрузке: мы незнаем сколько там ещё багажа и какаого он вида (общий, хрупкий, животные ...))
	2)Математические выражения неопределенной длины
	3)Поиск информации в интернете - пробегатся по сайтам пока не найдём нужную нам информацию


2)Как можно обработать по очереди все аргументы из пакета аргументов функции
	1)Рекурсия - извлекаем первый аргумент остальные отправляем снова в функцию
	2)выражения свёртки 4 типов
	

3)Как вычеслить количество параметров в пакете параметров вариативного шаблона
	1)sizeof...(Types или args) - может возникнуть проблемы с if так как независимо от условий будут инстанцироватся все возможные варианты
	2)Тогда воспользуемся if constexpr (sizeof...(args)    ) - особый if проверяемый на этапе компиляции

4)Какие существуют разновидности выражений свёртка и когда они применяются
	// (... op P) ((( p1 + p2 ) + p3) + ...) - можно использовать для вычесления многочлена произвольной длины
	// (P op ...) (...( p3 + ( p2 + p1 )))
	// (init op ... op P) -> ((init op p1) op p2) op ...  - использовали в print
	// (P op ... op init) -> (... p3 op( p2 op( p1 op init)))
	можно спутать свёртку с вариативным выражениями (отличия в том что в свёртке P - какой-то аргумент, а в выражении P - некоторое выражение )



5)В чём заключается разниуа между динамическим и статическим полиморфизмом
	1)динамический полиморфизм - это механизм, с помощью которого можно определить несколько методов
	с одинаковыми именами и сигнатурами в суперклассе и подклассе. 
	Реализуется через иерархию и виртуальные функции (вызывает самую дочернию функцияю)
	Выбор нужной функции происходит во время работы программы

	2)Статический полиморфизм - реализуется через шаблон и вызывается для конкретного переданного класса
	Нет необходимости в иерархи
	Выбор нужной функции происходит на этапе компиляции

	3)Патерн CRTP (curiously recurrent template pattern) - гибрид
		template < typename D >
		class Base {};

		class Derived : public Base < Derived > {};
	Позволяет избавится от затрат на виртуальные функции, использовать static_cast и (сохрнаить иерархию?).
	пример в базаовом классе реализована статическая переменная - но можно вести отдельные счётчики для каждого базового класса
		