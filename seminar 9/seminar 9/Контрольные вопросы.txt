1)Что такое шаблон и какие разновидности шаблонов существуют
	1)Шаблон template< typename T> — это конструкция, которая создает обычный тип или функцию во время компиляции на основе аргументов ,
	предоставленных пользователем для параметров шаблона. 
	2)Шаблон функции(max, min) - задаём семейство функций с одинаковым алгоритмом действий,
		template < typename T1, typename T2, typename RT = std::common_type_t < T1, T2 > >
		RT max(T1 a, T2 b)
		{
			return b < a ? a : b;
		}

	3)Шаблон класс(std::vector)
	template < typename T >
		class Stack
		{
		T top() const;
		...
		}
		template < typename T > const T & Stack < T > ::top() const
		{
			if (empty())
			{
				// ...
			}

			return values.back();
		}
	4)Шаблон псевдонима
	5)шаблоны переменных (число Пи)

2)каким образом осуществляется двух этапное инстанирование шаблона
	1)Инстанцирование - процесс превращения базового шаблона в конкретную версию обЪекта проходит в 2 этапа
		1)Этап - проверка кода без подстановки типа (выявляет синтаксические ошибке)
		2)Этап - проверка кода с подставлением конкретного типа (остальные ошибки к примеру наличие функции и операторов для подфункций шаблона)
	2)Нельзя разделить объявления и определения шаблона

3)Что предпочитает компилятор при перегрузке шаблона функции
	1)если мы напишим перегрузку шаблона не шаблонной функцией, то компилятор(ленивый) предпочтёт выбрать не шаблонный вариант,
	потому что мы избежим инстанцирования
	2)Если у нас есть частичная специализация подходящая под задаваемые аргкменты компилятор предпочтёт её.

4)В чем заключаеся особенность инстанцирования шаблонов класс
	1)если в коде нет какой-то шаблонной функции класса он просто не сгенерирует эту функцию

5)Когда необходима полная и частичная специализация шаблонов 
	1)Стоит использовать специализацию для оптимизации кода с определёнными типамами переменных
	2)актуально в std::vector<string>, чтобы соблюдать общий синтаксис для создания переменной, а не создавать новый класс с другим именем
	3)полная специализация - (явно указываются типы всех аргументов) 
	4)частичная специализация запрещена для функции(предпочтительней просто написать перегрузку)
	5)Может возникнуть конкурирование при частичной специализации если в треугольных скобках указать явно типы аргументов
	// X < int, int     > ().f(); // {T,T} or {T1,int}
	// X < int*, int*   > ().f(); // {T,T} or {T1*,T2*}