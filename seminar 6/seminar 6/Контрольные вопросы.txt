1)Перечислети все специальные функции-члены класса
	1)конструктор по умолчанию
	2)конструктор пользовательский
	3)Копироющий конструктор
	4)Перемещающий конструктор
	5)Оператор копирующего присваивания
	6)Оператор перемещающего присваивания
	7)деструктор

2)Приведите примеры операторов которые можно, нельзя и не рекомендуется перегркжать
	1)Можно (+,-,*,/,>,<,!,[],{}, >> ...)
	2)Не стоит (&, ,,&&, ||,)
	3)Нельзя (::, ., .*)

3)О каких преобразованиях следует помнить при проектирование операторов
	1)По умолчанию язык C++ обрабатывает любой конструктор, как оператор неявного преобразования.
	2)explicit - делает конструктор явным
	3)Иногда можно добавлять неявные преобразования своего класса в стандартные

4)Опишите классификацию выражений на основе перемещаемости и идентифицируемости
	1)rvalue/lvalue - по стандартам С++ у lvalue можно получить адрес а у rvalue нет
	2)lvalue занимает какую-то конкретную ячеёку в памяти и его можно идентифицировать
	3)Результатом выполнения какой-то функции будет временный безымянный обЪект который уничтожится - rvalue
	4)если мы создадим ссылку на результат этой функции то обЪект приобрёл свойстово lvalue и это уже не rvalue
	5)По итогу lvalue(i && !m) <--- gvalue(i) ---> xvalue(i && m) <--- rvalue(m) ---> prvalue(!i && m)

5)Зачем нужны rvalue - ссылки
	1)Они позволяют избегать логически ненужного копирования 
	2)lvalue-ссылку нельзя связать с временным объектом, а rvalue-ссылку можно
	3)Для семантики перемещения

6)Почему семантика перемещения лучше копирования
	1)Если нам нужна только одна копия объекта нет смысла его хранить дважды -> можно переместить и сэкономить память
	2.1)Копирование массива. Нам нужно (выделить память, записать ссылку на первый элемент, скопировать все элементы массива)
	2.2)Перемещение достаточно переопредилить ссылку на первый элемент и длину массива, а у объекта из которого копировали обнулить
		длину и присвоить ссылке nulptr
		2.2 - быстрее и проще реализуется

7)Что делает функция std::move и когда нет необходимоси явно её вызывать
	1)std::move() - конвертирует передаваемый аргумент в rvalue-ссылку
	2)Не надо использовать семантику перемещения при возврате результата работы функции, т.к. компилятор сам делает эфективное перемещение
	или может встроить функцию как кусок кода.(RVO/copy elision)

8)Кем непоредственно выполняется работа по перемещению
	1)Если я правильно понял вопрос то речь идёт о том, что непосредственно само перемещение делает не std::move(), а специальные перемещающие
	операции.

9)Когда может потребоватся пользовательская релизация специальных функций-членов класса 
	1)По дефолту компилятор сам создаёт специальные функции, но можем реализовать их самостоятельно. 
	Это необходимо, когда наш класс имеет какую-то особую структуру в памяти к примеру массив
	В Массиве мы храним ссылку на первый элемент(S) и длину(L), но сам масcив это блок памяти длиной(L) после блока S.
	2)Функция созданная компилятором знает только о L и S, поэтому скопирует только их, но нам нужно ещё скопироватьи значение в самих ячеёках.

10) Для чего нужны специальные слова default и delete в объявлении специальных функций-членов класса
	1)default - отдаёт команду компилятору сгенирировать данную функцию по умолчанию
	2)delete - запрещает программе как либо обращатся к данному элементу, таким образом можно запретить пользоватся конструктором копирования.
	3)Так же существуют override - проверяет существование метода с данной сигнатурой в базовом классе. Если же такого метода нет — выдает ошибку.
	4)final - позволяет запрещать в классах-наследниках переопределение определенных методов.


