1)Какие существуют способы обработки ошибок
	1)Обработка ошибок на месте
	1.1)if/else + while - перезапускать кусок кода при обнаружении ошибки с уведомлением о небходимость исправить
	1.2)abort/ terminate/ exit - при обнаружении ошибки аварийное завершение программы
		abort() - принудительно завершит программу (предварительно сбросив и закрыв стандартные потоки и сделав дамп памяти программы)

		exit() - указывает на "нормальный" конец программы, хотя это может указывать на сбой (но не на ошибку). Другими словами, вы можете exit с 
		кодом ошибки, если пользователь ввел ввод, который не может быть проанализирован, или файл не может быть прочитан. Код выхода 0 указывает
		на успех. exit также необязательно вызывает обработчики перед завершением программы. Они зарегистрированы в atexit а также on_exit функции.

		terminate - когда механизм управления особыми ситуациями не смог найти обработчик для запущенной особой ситуации;
				  - когда механизм управления особыми ситуациями столкнулся с нарушенной структурой стека;
				  - когда деструктор, вызванный в процессе раскрутки стека при запуске особой ситуации, сам пытается завершить выполнение программы,
				  запустив особую ситуацию.

	1.3)assertion - (проверка Выражения) - Если условное выражение истинно, то стейтмент assert ничего не делает. Если же оно ложное, то выводится
		сообщение об ошибке, и программа завершается. Это сообщение об ошибке содержит ложное условное выражение, а также имя файла с кодом и номером
		строки с assert.
		Можно отключить - для ускорения работы программы на релизной версии.
	2)Передача информации об ошибке
	2.1)Механизм исключения(try-catch-trow) - находит, перехватывает, генерирует ошибку при неправильном поведении программы
		try - ищит ошибки
		catch - используется для определения блока кода, который обрабатывает исключения определенного типа данных.
		trow - Сигнализирование о том, что произошло исключение, называется генерацией исключения
		1)многоуровневость - f->g->h (ошибка в h автомотически передаются в f)
		2)побочныйе расходы (если искл нет то нет побочных расходов)
		3)Преобразование - переход от произвольного класса к базовому

	2.2)return (some_erorr() - возвращает уведомление об ошибке(код ошибки)/ static errno - хранит значение последней ошибки/
	boost(&/*error) - переменной по ссылке или указателю присваивает код ошибки)
	3.3)Другие способы

2)В чём заключается недостаток механизмов кода возврата
	1)Иногда трудно понять что вернула программа код возврата или результат работы функции. Можно использовать (Мат функция --> union(std::variant)).
	2)Мы не котролируем время жизни статической переменной
	3)использование ссылок и указателей усложняет синтаксис
	4)К-Р, operator(не используем)

3)Какими особенностями обладает механизм исключений?
	1)многоуровневость - f->g->h (ошибка в h автомотически передаются в f)
	2)побочныйе расходы (если искл нет то нет побочных расходов) - т.к сама ошибка генерируется только когда находится исключение
	3)Преобразование - переход от произвольного класса к базовому(можно создавать пользовательские классы ошибок)
 

4)Для чего используется оператор noexept
 1)noexept - указывает компилятору что данная функция не выбрасывает исключений, что улучшает оптимизацию
 (компилятору не нужно беспокоиться о сохранении стека времени выполнения)
 2)noexept не запрещает функции выбрасывать исключения или вызывать другие функции, которые выбрасывают исключения
 3) noexcept(true) равносильно noexcept, что означает, что функция не является выбрасывающей;
	noexcept(false) означает, что функция относится к классу потенциально выбрасывающих исключения функций.
 4)Ипользовать спецификатор noexcept стоит лишь в конкретных случаях, когда вы хотите явно указать на гарантию отсутствия сбоя
	или отсутствие выбрасывания исключения(геттеры, операторы копирования, К-Р копирования и все специальные функции-члены сгенерированные по умолчанию)

5)Как формулируются гарантии безопасности исключений
	1)Базовая гарантия — если возникнет исключение, то утечки памяти не произойдет (все ресурсы будут освобождены корректно идиома RaII),
	и объект все еще будет использоваться, но программа может быть оставлена в измененном состоянии.
	2)Строгая гарантия — если возникнет исключение, то утечки памяти не произойдет (все ресурсы будут освобождены корректно),
	состояние программы не будет изменено. Это означает, что функция должна корректно завершить свою работу, либо не иметь побочных эффектов в случае,
	если функция аварийно завершила свою работу. 
	Простыми словами — если при выполнении операции возникнет исключение, то программа останется в том же состоянии, которое было до начала выполнения операции.
	3)Гарантия отсутствия исключений/сбоев — работа функции всегда завершается успешно (без сбоев) или завершается аварийно, но без выбрасывания исключений.
