1)Перечислети и прокоментируйте основные вырианты отношений между классами
	1)Композиция - (класс внутри класс) 
		1.1)Вложенный классс виден внутри главного класса, но чтобы получить доступ из вне надо писать (MainClass::NestedClass)
		1.2)Главный класс не имеет доступ к приватным и защещённым членам вложенного класса
		1.3)Вложенный класс не знает о существовании главного и класса и не имеет к ниму доступ.
		1.4)Когда удаляется Главный класс удаляется и вложенный
		1.5)Вложенные классы используется для скрытия реализации и помещаются в приватную секцию

	2)Агрегация - (ссылка на внешний класс внутри главного класса)
		2.1)главный класс может обратится к внешнему классу и получить только публичные члены
		2.2)главный класс не контролирует время существования внешнего класса
		2.3)Несколько классов могут ссылатся на внешний класс
		2.4)Внешний класс не знает что за обЪект к ниму обращается
		2.5)Можно создать класс Человек и класс Адрес - адрес существует сам по себе, а человек может обращатся к адресу 

	3)Ассоциация - (взаимные ссылки обЪектов, классов друг на друга)
		3.1)Класс 1 ссылается на класс 2 и может к ниму обратится 
		3.2)Класс 2 ссылается на класс 1 и может к ниму обратится
		3.3)Может быть несколько Ссылок на один и тотже класс
		3.4)Классы не котролируют друг друга
		3.5)Пример из 4 семинара (student <--> lesson)

	4)Зависимость - (использование главным классом внешнего обЪекта)
	 4.1)Не хранится прямая связь с обЪектом через переменную член но класс может воспользоватся внешним обЪектом
	 4.2)Пример std::cout мы используем другими классами для вывода но не наобарот

2)Какие существуют разновидности наследования и для чего они предназначенны
	1)Есть три типа наследования классов (открытое public, закрытое private, защищённое protected)

	2)При открытом наследование - спецификация членов остаётся такой же. 
	унаследованные public-члены остаются public, унаследованные protected-члены остаются protected, 
	а унаследованные private-члены остаются недоступными для дочернего класса. 
	Открытое наследование самое распросранённое - использоватся для случаев когда есть какой-то базовый класс,
	который описывает подмножество других классов. Примером являются те же фигуры.

	3)При закрытом наследовании все члены родительского класса наследуются как закрытые. 
	Это означает, что private-члены остаются недоступными, а protected- и public-члены становятся private в дочернем классе.
	Закрытое наследование может быть полезно, когда дочерний класс не имеет очевидной связи с родительским классом, но использует его в своей реализации.
	В таком случае мы не хотим, чтобы открытый интерфейс родительского класса был доступен через объекты дочернего класса

	4)С защищенным наследованием, public- и protected-члены становятся protected, а private-члены остаются недоступными.
	 Используется очень редко

	5)protected это когда наследник имеет доступ к члену класса а сам пользователь нет

	6)Есть ёще виртуальное наследование которое призваное решить проблему ромбовидного наследования (A-->B-->)|--> D (создаётся 2 обекта класса A)
																									(A-->C-->)|
	При виртуальном наследование где-то в памяти создаётся таблица где записан A, и когда мы пытаемя обратится к А программы сначала ищет обЪект в таблице
	Может приводить к уменьшению скорости работы так как будет выполнятся поиск

3)Что необходимо для корректного функционирования виртуальных функции
	1)Необходимо к.с virtual(override - позволяет отслеживать ошибки в переопределении функции, пишится после перечисления переменных функции)
							(final - запрещает переопределять функцию наследникам)
	2)Иерархия
	3)Сигнатура - одиноковое обЪявление
	4)Работа через ссылки или указатели
	5)Допускается изменение реализации
	6)Нельзя использовать виртуальную функцию в конструкторах и деструкторах так как обЪект от которого мы хотим вызвать функцию может быть ещё не создан
	7)Констрктор и деструктор обязательно виртуальные - это для того чтобы они вызывались последовательно то есть
	(сначало деструктор потомка, после деструктор родителя)
	8)При компиляции внутри класса с виртуальными функция создаётся ссылка на таблицу (vtbl)

4)Какую проблему решают виртуальные классы
	1)При создание двух классов(B1,B2) которые являются наследниками (A). Класс С наследник (B1,B2) 
	2)Если попытаться вызвать метод определенный в A то у нас возникнит ошибка не однозначности т.к у нас возникает два экземпляра класса A.
	Эту проблему решает виртуальный класс, который теперь единственный и его наследники хранят ссылку на этот класс

5)назовите и прокоментируйте основные патерны проектирования
	1)Порождающий - new(Factory) отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов.
	Абстрактная фабрика - используется для ситуации когда у нас нужно реализовать семейство схожих объектов и могут добавлятся новые объекты и семейства
	Чтобы не раскать по всему коду где нужно что-то поправить мы создадим одельную функцию котороя будет заниматься созданием объектов и подставим её в общий код

	2)Структурный - в которых рассматривается вопрос о том, как из классов и объектов образуются более крупные структуры.
	Adapter - объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту.

	3)Поведенчиский - определяющие алгоритмы и способы реализации взаимодействия различных объектов и классов.
	Tomplare_Method, sdrategy (идиома NVI виртуальные функции в приват)
	Template_method - разбивает алгорит на определённые шаги и позволяет кусочно менять реализацию сохраняя структуру
