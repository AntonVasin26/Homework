1) Что обеспечивает идеальная передача и как она реализуется?
	Идеальное передача позволяет сохранить фундаментальные свойства(модивицируемость, перемещаемость, const) обекта.
	Обеспечивается условным приведением обекта к rvalue (std::forward<>())

2) Какая ссылка назвается пробрасывающей или универсальной? 
	появилась в С++11
	Пробрассывающая ссылка определется компилятором (&&) в следующих ситуациях
	template < typename T > - когда используется шаблон
	void f(T && arg) {}
	auto && - когда используется auto
	Преобразование происходит следующим принципом
	// int x = 42;          f(x);  T = int&, arg = int& && -> int&
	// const int cx = 42;   f(cx); T = const int&, arg = const int &
	// const int & rx = cx; f(rx); T = const int&, arg = const int &
	//                      f(42); T = int, arg = int&&
	//                      f(std::move(x)); T = int&&, arg = int&& && -> int&&

3)В чем заключается идиома SFINAE применительно к шаблонам? 
	substitution failure is not an error -  «неудавшаяся подстановка — не ошибка»
	Игнорирование шаблона если он не подходит - если при компиляции шаблон будет некорректный, то компилятор проигнориет его
	и будет искать алтернативу.

4) Как можно использовать вспомогательный шаблон enable_if?
	работает следующим образом
	// std::enable_if_t < Condition(условие) >
	// std::enable_if_t < True  > -> void
	// std::enable_if_t < False > -> (пустое место)
	// std::enable_if_t < True, X > -> X 
	// std::enable_if_t < False, X > -> (пустое место) 
	При использование в шаблонах, если условие false, тогда шаблон не корректен и по идимо SFINAE
	он игнорируется и компилятор ищет альтернативу.
	Варианты реализации в файле "enable_if.pdf" предпочтительны варианты 1,3
	Вспомогательные функции (std::is_same_t(), std::is_convertible_v)

5) Какие правила вывода применяются при работе с шаблонами?
	Я не уверен что правильно понял что подразумевается под выводом типа шаблон - это типо, как компилятор собирёт экземпляр шаблонной функции?
	По умолчанию - по значению
		Выполняется копирование(но есть оптимизации - компилятор может применить перемещение если обект используется последний раз)
		Использование std::ref(), std::cref() - обёртки вокруг объекта(обеспечивающие ссылочность)
		Безопасно для возвращаемого знаяение(не пропадут временные объекты)
		Есть низведение типа для общности
	Передача по ссылке
		лучше производительность - но это не  точно(надо измерять)
		модикация исходных объектов
		пробрасывающий шаблон(правила свёртывания ссылок, std::forward<>())

	ещё видел вот такую штуку на habr (https://habr.com/ru/post/414233/)
		При выводе типа T ссылочность (*, &) отбрасывается, потому что она уже указана при определении функции
		входной тип —> тип, параметр —> выведенный тип [, конечный-тип параметра]
		// отбрасывается ссылочность
		int —> (T & param) —> int;
		const int —> (T & param) —> const int;
		const int & —> (T & param)  —> const int

		// отбрасывается константность
		int —> (const T & param) —> int;
		const int —> (const T & param) —> int;
		const int & —> (const T & param) —> int;

		// отбрасывается ссылочность  
		int * —> (T * param) —> int;
		const int —> (T * param) —> const int;
		const int * —> (T * param)  —> const int;

		// отбрасывается константность
		int * —> (const T * param) —> int;
		const int —> (const T * param) —> int;
		const int * —> (const T * param)  —> int;